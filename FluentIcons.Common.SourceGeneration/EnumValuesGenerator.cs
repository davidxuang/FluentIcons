using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace FluentIcons.Common.SourceGeneration;

[Generator]
public sealed class EnumValuesGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var declarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                (node, _) => node is EnumDeclarationSyntax declaration && declaration.Parent is not EnumDeclarationSyntax,
                (ctx, _) => (EnumDeclarationSyntax)ctx.Node)
            .Collect();

        context.RegisterSourceOutput(declarations.Combine(context.CompilationProvider), (spc, source) =>
        {
            var (enums, compilation) = source;
            foreach (var declaration in enums)
            {
                var model = compilation.GetSemanticModel(declaration.SyntaxTree);
                if (model.GetDeclaredSymbol(declaration) is not INamedTypeSymbol symbol)
                    continue;

                var ns = symbol.ContainingNamespace.ToDisplayString();
                var name = symbol.Name;
                var members = symbol.GetMembers().OfType<IFieldSymbol>().Where(f => f.HasConstantValue);
                if (members.Count() > 256) continue;

                var values = string.Join(", ", members.Select(m => $"{name}.{m.Name}"));
                var code = $@"// <auto-generated/>
using System.Collections.Generic;

namespace {ns}
{{
    public static class {name}Values
    {{
        public static readonly IEnumerable<{name}> Enumerable = new[] {{ {values} }};
    }}
}}";

                spc.AddSource($"{name}Values.g.cs", SourceText.From(code, Encoding.UTF8));
            }
        });
    }
}
